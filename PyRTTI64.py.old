import pefile
import struct
import sys

from ctypes import *

from ctypes.wintypes import *

_undecorate_ = WinDLL('dbghelp.dll', use_last_error=True).UnDecorateSymbolName
_undecorate_.argtypes = [LPCSTR, LPSTR, DWORD, DWORD]
_undecorate_.restype = DWORD

def UndecorateSymbol(symbol):
    maxStrLen = 0x1000
    buffer = create_string_buffer(maxStrLen)
    _undecorate_(symbol ,buffer, maxStrLen, 0)
    return buffer.value


pointer_size = 8
pointer_format = "Q"
CompleteObjectLocator = struct.Struct("IIIII")

def find_patterns(data, pattern, mask):
    patternlist = []
    for i in range(len(data)):
        for x in range(len(mask)):
            if (data[i+x] == pattern[x]) or (mask[x] == 0x3F):
                if x == len(mask)-1:
                    patternlist.append(i)
            else: break
    return patternlist

def find_type_vftable(data):
    index = data.find(b'.?AVtype_info@@')
    if index != -1:
        index = index - (pointer_size*2)
        return data[index:index+8]
    else:
        print("ERROR: Data Not Found")
    return None


def find_first_reference(data, addr):
    bytes = struct.pack("Q", addr)
    index = 1
    while index != -1:
        index = data.find(bytes, index)
        if index != -1:
            return index
            index+=1

target = "C:\\Program Files (X86)\\Steam\\steamapps\\common\\Sekiro\\sekiro.exe"
print("loading -> ", target)
file = open(target, 'rb')
data = file.read()
file.close()

exe = pefile.PE(target)
print("done!")



dumpfile = open('vftable.txt', 'w')
print("scanning for type_info...")
type_vftable_rva = struct.unpack(pointer_format, find_type_vftable(data))[0]
type_vftable_rva = type_vftable_rva - exe.OPTIONAL_HEADER.ImageBase
type_vftable_offset = exe.get_offset_from_rva(type_vftable_rva)
type_meta_offset = type_vftable_offset - pointer_size
temp = data[type_meta_offset:type_meta_offset+pointer_size]
type_meta_offset = exe.get_offset_from_rva((struct.unpack(pointer_format, temp)[0])-exe.OPTIONAL_HEADER.ImageBase)
type_meta_data = data[type_meta_offset:type_meta_offset+24]
print("found! type_info_objectlocatordata:")
print(type_meta_data)

print("\nscanning for CompleteObjectLocators...")
objectLocators = find_patterns(data, type_meta_data, b'xxxxxxxxxxxx???x???x')
print("found", len(objectLocators), " classes")

for objectLocator in objectLocators:
    sig, offset, cdOffset, pTypeDescriptorRVA, pClassDescriptorRVA = CompleteObjectLocator.unpack(data[objectLocator:objectLocator+CompleteObjectLocator.size])
    meta_vftable = find_first_reference(data, exe.get_rva_from_offset(objectLocator) + exe.OPTIONAL_HEADER.ImageBase)
    if(meta_vftable != None):
        vftable = meta_vftable + pointer_size
        va_vftable = exe.OPTIONAL_HEADER.ImageBase + exe.get_rva_from_offset(vftable)
        symbol = exe.get_string_at_rva(pTypeDescriptorRVA+pointer_size*2)
        symbol = b'??_7' + symbol[4:] + b'6B@'
        symbol = UndecorateSymbol(symbol).decode('ASCII')
        dumpfile.write(str(hex(va_vftable)) + " | " + symbol + "\n")        

dumpfile.close
print("done!")